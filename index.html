<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5 Minute Dungeon Modified Timer</title>
  <style>
    /* Basic styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      transition: background-color 0.5s ease;
    }
    /* Encounter Timer Bar (Phase 2 Timer) */
    .top-bar {
      background-color: #333;
      color: white;
      text-align: center;
      width: 90vw;
      max-height: 10vh;
      margin: 10px auto;
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: clamp(1.5em, 5vw, 5vh);
      overflow: hidden;
      white-space: nowrap;
    }
    /* Recon Timer Bar (Phase 1 Timer) */
    .recon-bar {
      background-color: #555;
      color: white;
      text-align: center;
      width: 90vw;
      max-height: 10vh;
      margin: 10px auto;
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: clamp(1.5em, 5vw, 5vh);
      overflow: hidden;
      white-space: nowrap;
    }
    .container {
      margin-top: 20px;
      padding: 20px;
      text-align: center;
      position: relative;
    }
    .phase {
      display: none;
    }
    .active {
      display: block;
    }
    button {
      font-size: 1.5em;
      padding: 15px 20px;
      margin: 10px;
      cursor: pointer;
    }
    /* Modal styling */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: #fefefe;
      margin: 10% auto;
      padding: 20px;
      border: 1px solid #888;
      width: 300px;
      text-align: left;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-close {
      float: right;
      cursor: pointer;
      font-size: 20px;
    }
    /* Buttons for Settings & Encounter Selection */
    #settingsButton, #chooseEncountersButton {
      font-size: 1.5em;
      padding: 15px 20px;
      margin: 10px;
    }
    #pauseResumeButton {
      float: left;
      font-size: 1.5em;
      padding: 15px 20px;
      margin: 10px;
    }
    /* Capsule Toggle Switch styling */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 9vh;
      height: 5vh;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 25px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: calc(5vh - 4px);
      width: calc(5vh - 4px);
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    .toggle-switch input:checked + .slider {
      background-color: #2196F3;
    }
    .toggle-switch input:checked + .slider:before {
      transform: translateX(calc(9vh - 5vh));
    }
    /* Larger input fields in modal */
    input[type="number"], input[type="text"] {
      height: 2.5em;
      font-size: 1em;
      padding: 5px;
      margin: 5px 0;
    }
    /* Encounter Selection Modal: Tab structure */
    .tab-container {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px;
    }
    .tab-button {
      flex: 1;
      padding: 10px;
      cursor: pointer;
      background: #eee;
      border: 1px solid #ccc;
      text-align: center;
    }
    .tab-button.active {
      background: #ddd;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Encounter Timer Bar (Phase 2 Timer) -->
  <div class="top-bar" id="encounterTimerBar">
    Encounter Timer: 05:00
  </div>
  <!-- Recon Timer Bar (Phase 1 Timer); hidden by default -->
  <div class="recon-bar" id="reconTimerBar" style="display:none;">
    Recon Timer: 00 sec
  </div>
  <!-- Penalty Warning message shown under the recon timer bar -->
  <p id="penaltyWarning" style="text-align: center; color: red; font-size: 1.2em; display: none;"></p>
  
  <div class="container">
    <!-- Start Game Button -->
    <button id="startReconButton">Start Recon</button>
    
    <!-- Encounter Selector Button -->
    <button id="chooseEncountersButton">Choose Encounters</button>
    
    <!-- Recon Phase (Phase 1) -->
    <div id="phase1" class="phase">
      <h1 id="encounterName"></h1>
      <p id="phase1Instruction">Recon Phase: Identify the encounter displayed above.</p>
      <button id="startEncounterButton">Start Encounter</button>
      <br>
      <button id="penaltyButton">Misidentified Encounter</button>
      <button id="cancelPenaltyButton">Cancel Penalty</button>
    </div>
    
    <!-- Encounter Phase (Phase 2) -->
    <div id="phase2" class="phase">
      <p id="phase2Instruction">Encounter Phase in progress. Timer is counting down.</p>
      <button id="completeEncounterButton">Complete Encounter</button>
    </div>
    
    <!-- Pause/Resume Button -->
    <button id="pauseResumeButton">Pause</button>
    
    <!-- Settings Button -->
    <button id="settingsButton">Settings</button>
  </div>
  
  <!-- Settings Modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" id="closeModal">&times;</span>
      <h2>Settings</h2>
      <!-- Challenge Mode Toggle -->
      <div style="display: flex; align-items: center; justify-content: center;">
        <span style="margin-right: 10px; font-size:1em;">Challenge Mode</span>
        <label class="toggle-switch">
          <input type="checkbox" id="challengeModeToggle">
          <span class="slider"></span>
        </label>
      </div>
      <!-- Challenge Mode Settings -->
      <div id="challengeModeSettings" style="display: none; margin-top: 10px;">
        <p style="font-size: 0.9em; margin: 5px 0;">
          When enabled, a separate timer for the Recon Phase will start.
          If it counts down to zero before starting the encounter, a penalty is applied (subtracting the penalty time from the current Encounter Timer).
        </p>
        <label for="phase1TimerInput">Recon Timer Length (seconds):</label>
        <input type="number" id="phase1TimerInput" value="10" />
      </div>
      <br>
      <!-- Penalty Time setting -->
      <label for="penaltyTimeInput">Penalty Time (seconds):</label>
      <input type="number" id="penaltyTimeInput" value="10" />
      <br><br>
      <button id="saveSettingsButton">Save</button>
    </div>
  </div>
  
  <!-- Encounter Selection Modal with Tab Structure -->
  <div id="encounterModal" class="modal">
    <div class="modal-content">
      <span class="modal-close" id="closeEncounterModal">&times;</span>
      <h2>Select Encounters</h2>
      <!-- Tab Navigation -->
      <div class="tab-container">
        <button class="tab-button active" data-type="event">Event</button>
        <button class="tab-button" data-type="mini-boss">Mini-Boss</button>
        <button class="tab-button" data-type="monster">Monster</button>
        <button class="tab-button" data-type="obstacle">Obstacle</button>
        <button class="tab-button" data-type="person">Person</button>
      </div>
      <!-- Search Field -->
      <input type="text" id="encounterSearchInput" placeholder="Search encounters..." />
      <!-- Container for Encounter List -->
      <div id="encounterListContainer"></div>
      <br>
      <button id="saveEncountersButton">Save Selection</button>
    </div>
  </div>
  
  <script>
    // Timer and game logic
    
    // Encounter Timer (Phase 2) duration: 5 minutes (in seconds)
    let timerDuration = 300;
    let remainingTime = timerDuration;
    let timerInterval = null;
    
    // Encounter list from PDF
    let encounterList = [
      { name: "AMBUSH!", type: "event" },
      { name: "A BOO-BOO", type: "event" },
      { name: "CONFUSION", type: "event" },
      { name: "DUNGEON ERROR IN YOUR FAVOR", type: "event" },
      { name: "GIMME A HAND!", type: "event" },
      { name: "LOCKED DOOR!", type: "event" },
      { name: "YET MORE SPIKES!", type: "event" },
      { name: "SUDDEN ILLNESS", type: "event" },
      { name: "TRAP DOOR", type: "event" },
      { name: "AN UNGODLY AMOUNT OF PORCUPINES", type: "event" },
      { name: "DAS BOOT!", type: "mini-boss" },
      { name: "THE DREADED TRI-BREAD", type: "mini-boss" },
      { name: "GIANT ENEMY CRAB", type: "mini-boss" },
      { name: "THE GOBLIN KING", type: "mini-boss" },
      { name: "A LOW-TECH MECH", type: "mini-boss" },
      { name: "A VERY MINI MINI-BOSS", type: "mini-boss" },
      { name: "A MINIATURE T-REX", type: "mini-boss" },
      { name: "THE RAT KING", type: "mini-boss" },
      { name: "THE COLLECTOR", type: "mini-boss" },
      { name: "A WIZARD OF ILL REPUTE", type: "mini-boss" },
      { name: "A RATHER UNPLEASANT PHEASANT", type: "monster" },
      { name: "ADORABLE SLIME", type: "monster" },
      { name: "A CACTUS THAT WANTS A HUG", type: "monster" },
      { name: "THE DUCK OF CANTERBURY", type: "monster" },
      { name: "EEEEWWWWWWW", type: "monster" },
      { name: "A GAB-ERWOCKY", type: "monster" },
      { name: "GORBLIN", type: "monster" },
      { name: "GRIFFIN-DOOR", type: "monster" },
      { name: "LOTS AND LOTS OF ZOMBIES", type: "monster" },
      { name: "A ROSETTA STONE GOLEM", type: "monster" },
      { name: "SHARK WITH LEGS!!", type: "monster" },
      { name: "SIR FUZZYLUMPS", type: "monster" },
      { name: "A STRAIGHT-UP GHOST", type: "monster" },
      { name: "A SUSPICIOUS LOOKING CRATE", type: "monster" },
      { name: "THE CHROMICORN", type: "monster" },
      { name: "A TIMBER-WOLF", type: "monster" },
      { name: "A CREATURE OF UNFATHOMABLE EVIL", type: "monster" },
      { name: "UUGGHH... BOOTS", type: "monster" },
      { name: "A DEFINITELY NOT BOOBY-TRAPPED CHEST", type: "obstacle" },
      { name: "BOTTOMLESS PIT", type: "obstacle" },
      { name: "JUST A BUNCH OF STAIRS", type: "obstacle" },
      { name: "THE CARPAL TUNNEL", type: "obstacle" },
      { name: "A CHAIR THAT IS VERY UNCOMFORTABLE", type: "obstacle" },
      { name: "COLLAPSED CEILING", type: "obstacle" },
      { name: "A DEADLY GAME or HOPSCOTCH", type: "obstacle" },
      { name: "DISAPPEARING BLOCKS", type: "obstacle" },
      { name: "INVISIBLE WALL", type: "obstacle" },
      { name: "JACK THE RIPPER IN A BOX", type: "obstacle" },
      { name: "A LITERAL STRAWHAN", type: "obstacle" },
      { name: "LIVING VINES", type: "obstacle" },
      { name: "A VERY LONG LOADING SCREEN", type: "obstacle" },
      { name: "QUICKSAND", type: "obstacle" },
      { name: "SHORTCUT", type: "obstacle" },
      { name: "A SURPRISE DODGEBALL TOURNAMENT", type: "obstacle" },
      { name: "ONE GUY, TWO -BOWS", type: "person" },
      { name: "TWO GUYS, ONE BOW", type: "person" },
      { name: "7 UNHELPFUL DWARFS", type: "person" },
      { name: "EXACTLY 26 NINJAS", type: "person" },
      { name: "AN ARM DEALER", type: "person" },
      { name: "BARBER-ARIAN", type: "person" },
      { name: "AN OVERLY-DRAMATIC MONOLOGUE", type: "person" },
      { name: "GHOST", type: "person" },
      { name: "GROZZNAK THE TALL", type: "person" },
      { name: "MASSIVE PAULDRONS", type: "person" },
      { name: "AN OVERPRICED MERCHANT", type: "person" },
      { name: "A TERRIBLE, NO-GOOD, AWFUL PUPPET SHOW", type: "person" },
      { name: "A GAGGLE OF SCREAMING CHILDREN", type: "person" },
      { name: "A SLEEPING GIANT", type: "person" },
      { name: "SQUIRE NEDWARD", type: "person" },
      { name: "STEVE", type: "person" },
      { name: "THE NECROBOUNCER", type: "person" },
      { name: "A WARRIOR PRINCESS", type: "person" }
    ];
    
    // Global selection state: record checkbox state for each encounter (key: name-type)
    let selectedEncounterMap = {};
    // Initially, mark all encounters as selected.
    encounterList.forEach(enc => {
      const key = enc.name + "-" + enc.type;
      selectedEncounterMap[key] = true;
    });
    
    // These arrays will be used during gameplay
    let selectedEncounters = [...encounterList];
    let availableEncounters = [...selectedEncounters];
    
    // Default penalty time (in seconds)
    let penaltyTime = 10;
    
    // Challenge Mode variables for Recon Phase timer
    let challengeModeEnabled = false;
    let challengePhase1Duration = 10; // Recon Phase timer length in seconds
    let phase1ChallengeTimerRemaining = 0;
    let phase1ChallengeInterval = null;
    
    // Pause state variable
    let isPaused = false;
    
    // DOM Elements for timers and phases
    const encounterTimerBar = document.getElementById("encounterTimerBar");
    const reconTimerBar = document.getElementById("reconTimerBar");
    const penaltyWarning = document.getElementById("penaltyWarning");
    const phase1Div = document.getElementById("phase1");
    const phase2Div = document.getElementById("phase2");
    const encounterNameElem = document.getElementById("encounterName");
    
    const startReconButton = document.getElementById("startReconButton");
    const startEncounterButton = document.getElementById("startEncounterButton");
    const completeEncounterButton = document.getElementById("completeEncounterButton");
    const penaltyButton = document.getElementById("penaltyButton");
    const cancelPenaltyButton = document.getElementById("cancelPenaltyButton");
    
    const pauseResumeButton = document.getElementById("pauseResumeButton");
    const settingsButton = document.getElementById("settingsButton");
    const settingsModal = document.getElementById("settingsModal");
    const closeModal = document.getElementById("closeModal");
    const saveSettingsButton = document.getElementById("saveSettingsButton");
    const penaltyTimeInput = document.getElementById("penaltyTimeInput");
    const phase1TimerInput = document.getElementById("phase1TimerInput");
    const challengeModeToggle = document.getElementById("challengeModeToggle");
    const challengeModeSettings = document.getElementById("challengeModeSettings");
    
    // DOM Elements for Encounter Selection Modal
    const chooseEncountersButton = document.getElementById("chooseEncountersButton");
    const encounterModal = document.getElementById("encounterModal");
    const closeEncounterModal = document.getElementById("closeEncounterModal");
    const encounterSearchInput = document.getElementById("encounterSearchInput");
    const encounterListContainer = document.getElementById("encounterListContainer");
    const saveEncountersButton = document.getElementById("saveEncountersButton");
    const tabButtons = document.querySelectorAll(".tab-button");
    
    // Current tab filter; default to "event"
    let currentTab = "event";
    
    // Format seconds to mm:ss
    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
    }
    
    // Update Encounter Timer display (top bar)
    function updateEncounterTimerDisplay() {
      encounterTimerBar.textContent = "Encounter Timer: " + formatTime(remainingTime);
      if (remainingTime <= 0) {
        document.body.style.backgroundColor = "red";
      }
    }
    
    // Update Recon Timer display (Recon Phase bar)
    function updateReconTimerDisplay() {
      reconTimerBar.textContent = "Recon Timer: " + phase1ChallengeTimerRemaining + " sec";
    }
    
    // Start the Encounter Timer (Phase 2)
    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (remainingTime > 0) {
          remainingTime--;
          updateEncounterTimerDisplay();
          if (remainingTime <= 0) {
            clearInterval(timerInterval);
            alert("Time's up!");
          }
        }
      }, 1000);
    }
    
    // Stop the Encounter Timer
    function stopTimer() {
      if (timerInterval) clearInterval(timerInterval);
    }
    
    // Initialize Recon Phase (Phase 1)
    function initReconPhase() {
      stopTimer();
      if (availableEncounters.length > 0) {
        const randomIndex = Math.floor(Math.random() * availableEncounters.length);
        const encounter = availableEncounters.splice(randomIndex, 1)[0];
        encounterNameElem.textContent = encounter.name;
      } else {
        encounterNameElem.textContent = "No more encounters!";
      }
      
      penaltyWarning.style.display = "none";
      penaltyWarning.textContent = "";
      
      if (challengeModeEnabled) {
        phase1ChallengeTimerRemaining = challengePhase1Duration;
        updateReconTimerDisplay();
        reconTimerBar.style.display = "flex";
        if (phase1ChallengeInterval) clearInterval(phase1ChallengeInterval);
        phase1ChallengeInterval = setInterval(() => {
          phase1ChallengeTimerRemaining--;
          updateReconTimerDisplay();
          if (phase1ChallengeTimerRemaining <= 0) {
            clearInterval(phase1ChallengeInterval);
            remainingTime = Math.max(0, remainingTime - penaltyTime);
            updateEncounterTimerDisplay();
            reconTimerBar.style.display = "none";
            penaltyWarning.textContent = "Time expired, penalty applied.";
            penaltyWarning.style.display = "block";
          }
        }, 1000);
      } else {
        reconTimerBar.style.display = "none";
      }
    }
    
    // Transition to Encounter Phase (Phase 2)
    function goToEncounterPhase() {
      phase1Div.classList.remove("active");
      phase2Div.classList.add("active");
      startTimer();
    }
    
    // Transition back to Recon Phase (Phase 1)
    function completeEncounter() {
      stopTimer();
      phase2Div.classList.remove("active");
      phase1Div.classList.add("active");
      initReconPhase();
    }
    
    // Apply penalty by subtracting time from Encounter Timer
    function applyPenalty() {
      remainingTime = Math.max(0, remainingTime - penaltyTime);
      updateEncounterTimerDisplay();
    }
    
    // Cancel penalty by adding back the penalty time to Encounter Timer
    function cancelPenalty() {
      remainingTime = remainingTime + penaltyTime;
      if (remainingTime > timerDuration) {
        remainingTime = timerDuration;
      }
      updateEncounterTimerDisplay();
    }
    
    // Pause current timer
    function pauseCurrentTimer() {
      if (phase1Div.classList.contains("active") && challengeModeEnabled && phase1ChallengeInterval) {
        clearInterval(phase1ChallengeInterval);
        phase1ChallengeInterval = null;
      } else if (phase2Div.classList.contains("active") && timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }
    
    // Resume current timer
    function resumeCurrentTimer() {
      if (phase1Div.classList.contains("active") && challengeModeEnabled) {
        phase1ChallengeInterval = setInterval(() => {
          phase1ChallengeTimerRemaining--;
          updateReconTimerDisplay();
          if (phase1ChallengeTimerRemaining <= 0) {
            clearInterval(phase1ChallengeInterval);
            remainingTime = Math.max(0, remainingTime - penaltyTime);
            updateEncounterTimerDisplay();
            reconTimerBar.style.display = "none";
            penaltyWarning.textContent = "Time expired, penalty applied.";
            penaltyWarning.style.display = "block";
          }
        }, 1000);
      } else if (phase2Div.classList.contains("active")) {
        startTimer();
      }
    }
    
    // Event listeners for Pause/Resume button
    pauseResumeButton.addEventListener("click", () => {
      if (!isPaused) {
        pauseCurrentTimer();
        pauseResumeButton.textContent = "Resume";
        isPaused = true;
      } else {
        resumeCurrentTimer();
        pauseResumeButton.textContent = "Pause";
        isPaused = false;
      }
    });
    
    // Start Recon button
    startReconButton.addEventListener("click", () => {
      startReconButton.style.display = "none";
      phase1Div.classList.add("active");
      initReconPhase();
    });
    
    // Start Encounter button
    startEncounterButton.addEventListener("click", () => {
      if (challengeModeEnabled && phase1ChallengeInterval) {
        clearInterval(phase1ChallengeInterval);
        phase1ChallengeInterval = null;
      }
      reconTimerBar.style.display = "none";
      penaltyWarning.style.display = "none";
      goToEncounterPhase();
    });
    
    // Complete Encounter button
    completeEncounterButton.addEventListener("click", completeEncounter);
    
    penaltyButton.addEventListener("click", applyPenalty);
    cancelPenaltyButton.addEventListener("click", cancelPenalty);
    
    settingsButton.addEventListener("click", () => {
      settingsModal.style.display = "block";
    });
    
    closeModal.addEventListener("click", () => {
      settingsModal.style.display = "none";
    });
    
    saveSettingsButton.addEventListener("click", () => {
      const newPenalty = parseInt(penaltyTimeInput.value);
      if (!isNaN(newPenalty)) {
        penaltyTime = newPenalty;
      }
      challengeModeEnabled = challengeModeToggle.checked;
      if (challengeModeEnabled) {
        const newPhase1Duration = parseInt(phase1TimerInput.value);
        if (!isNaN(newPhase1Duration)) {
          challengePhase1Duration = newPhase1Duration;
        }
      }
      settingsModal.style.display = "none";
    });
    
    challengeModeToggle.addEventListener("change", () => {
      challengeModeSettings.style.display = challengeModeToggle.checked ? "block" : "none";
    });
    
    // -------------------------------
    // Encounter Selection Modal (Tab Structure)
    // -------------------------------
    
    // Function to update the encounter list display for the current tab and search query.
    function updateEncounterListDisplay() {
      const searchQuery = encounterSearchInput.value.toLowerCase();
      const filteredEncounters = encounterList.filter(enc => {
        return enc.type === currentTab && enc.name.toLowerCase().includes(searchQuery);
      });
      
      let html = "";
      filteredEncounters.forEach(enc => {
        const key = enc.name + "-" + enc.type;
        const isChecked = selectedEncounterMap[key] ? "checked" : "";
        html += `<div>
                   <label>
                     <input type="checkbox" class="encounterSelect" data-key="${key}" ${isChecked}>
                     ${enc.name}
                   </label>
                 </div>`;
      });
      encounterListContainer.innerHTML = html;
      
      // Add change listener for checkboxes to update the selection map.
      document.querySelectorAll('.encounterSelect').forEach(cb => {
        cb.addEventListener("change", (e) => {
          const key = e.target.getAttribute("data-key");
          selectedEncounterMap[key] = e.target.checked;
        });
      });
    }
    
    // Tab button event listeners: switch currentTab and update active styling.
    tabButtons.forEach(button => {
      button.addEventListener("click", () => {
        currentTab = button.getAttribute("data-type");
        tabButtons.forEach(btn => btn.classList.remove("active"));
        button.classList.add("active");
        updateEncounterListDisplay();
      });
    });
    
    // Update list when search input changes.
    encounterSearchInput.addEventListener("input", updateEncounterListDisplay);
    
    // Open the encounter modal
    chooseEncountersButton.addEventListener("click", () => {
      encounterModal.style.display = "block";
      updateEncounterListDisplay();
    });
    
    // Close encounter modal
    closeEncounterModal.addEventListener("click", () => {
      encounterModal.style.display = "none";
    });
    
    // Save Selection button: update global selection arrays based on selectedEncounterMap.
    saveEncountersButton.addEventListener("click", () => {
      // Build new selection from the entire encounterList where the map is true.
      selectedEncounters = encounterList.filter(enc => {
        const key = enc.name + "-" + enc.type;
        return selectedEncounterMap[key];
      });
      // Reset availableEncounters for gameplay.
      availableEncounters = [...selectedEncounters];
      encounterModal.style.display = "none";
    });
    
    window.onbeforeunload = function() {
      return "Warning: Resetting the timer!";
    };
    
    updateEncounterTimerDisplay();
  </script>
</body>
</html>
